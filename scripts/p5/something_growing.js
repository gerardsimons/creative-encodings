const W = 1000;
const H = 1000;

const BRANCH_DEPTH = 9;
const INITIAL_LENGTH_RANGE = [W/12, W/3]
const BRANCHES_PER_LEVEL = 3;
const MAX_BRANCHES = 500000;
const ROOT_THICKNESS = 10;

let tree = undefined;

DEBUG_DRAWS = false;
FRAME_RATE = 1;

function saveSVG() {

}

function savePNG() {

}

function getRandomBool() {
  return Math.random() >= 0.5;
}

function getRandomInt(min, max) {
  return Math.floor(Math.random() * Math.floor(max - min)) + min;
}

function getRandomFloat(min, max) {
  return Math.random() * (max - min) + min;
}

function randomPointOnLine(start, end) {
  const r = Math.random(); // between 0 and 1
  const diff = p5.Vector.sub(end, start);
  return new p5.Vector(start.x + Math.round(r * diff.x), start.y + Math.round(r * diff.y));
}

class TreeBranch {
  constructor(tree, start, dir, length, thickness) {
    if (thickness === undefined) {
      thickness = 1;
    }
    this.tree = tree;
    this.thickness = thickness;
    this.start = start;
    this.end = p5.Vector.add(start, p5.Vector.mult(dir, length));
    this.children = Array();
    this.dir = dir;
    this.length = length;
    this.invalidBB = true;
  }

  getMinX() {
    const self = Math.min(this.start.x, this.end.x);

    if (this.children.length) {
      return Math.min(self, this.children.reduce((total, currentValue) => {
        return Math.min(total, currentValue.getMinX())
      }, self));
    } else {
      return self;
    }
  }

  getMinY() {
    const self = Math.min(this.start.y, this.end.y);
    if (this.children.length)
      return Math.min(self, this.children.reduce((total, currentValue) => {
        return Math.min(total, currentValue.getMinY())
      }, self));
    else {
      return self;
    }
  }

  getMaxX() {
    const self = Math.max(this.start.x, this.end.x);
    if (this.children.length) {
      return this.children.reduce((total, currentValue) => {
        return Math.max(total, currentValue.getMaxX())
      }, self)
    } else {
      return self;
    }
  }

  getMaxY() {
    const self = Math.max(this.start.y, this.end.y);
    if (this.children.length)
      return this.children.reduce((total, currentValue) => {
        return Math.max(total, currentValue.getMaxY())
      }, self)
    else {
      return self;
    }
  }

  createBB() {
    const minX = this.getMinX();
    const minY = this.getMinY();
    const maxX = this.getMaxX();
    const maxY = this.getMaxY();
    this.bb = [minX, minY, maxX - minX, maxY - minY];
  }

  getBB() {
    if (this.bb === undefined) {
      this.createBB();
    }
    return this.bb;
  }

  branch(n, lengthRange, depth) {
    if (this.tree.totalNumBranches >= MAX_BRANCHES) {
      console.log("Max number of branches reached. Terminating")
      return;
    }
    // console.log(`Generating branch #{this.tree.totalNumBranches + 1}`)
    if (depth === 0) {
      return;
    }
    if (depth === undefined) {
      depth = 1;
    }

    // Find a random branch point
    for (var i = 0; i < n; i++) {
      const newStart = randomPointOnLine(this.start, this.end);
      const length = getRandomInt(lengthRange[0], lengthRange[1]);

      const left = getRandomBool();
    //   const relDir = 
      let dir;
      if (left) { //Whether to mirror this branch or not
        dir = p5.Vector.add(this.dir, p5.Vector.fromAngle(-getRandomInt(80, 100)))
      } else {
        dir = p5.Vector.add(this.dir, p5.Vector.fromAngle(getRandomInt(80, 100)))
      }
      const newBranch = new TreeBranch(this.tree, newStart, dir, length, max(Math.round(this.thickness * 0.5), 1));
      if(newBranch.end.x < 0 || newBranch.end.y < 0 || newBranch.end.x > W || newBranch.end.y > H) {
        return; // out of bounds ... do not create
      }
      
      this.children.push(newBranch);
      this.tree.totalNumBranches++;
      newBranch.branch(depth - 1, [lengthRange[0] * 0.5, Math.floor(lengthRange[1] * 0.5)], depth - 1);
    }
  }

  draw() {

    stroke(0, 0, 0, 100 * this.thickness);
    strokeWeight(this.thickness)
    line(this.start.x, this.start.y, this.end.x, this.end.y);

    for (var i in this.children) {
      this.children[i].draw();
    }
  }
}


/*
 * A tree is generated by definining a start point and an initial direction.
 * Based on other parameters we recursively split this line into multiple other lines 
 * and so forth
 */
class Tree {
  constructor(origin, dir, rootThickness) {
    console.log("Tree created (origin,dir)=", origin, dir)
    this.origin = origin;
    this.dir = dir;

    // const length = getRandomInt([])
    const length = 100

    this.mainBranch = new TreeBranch(this, origin, dir, length, rootThickness)
    this.totalNumBranches = 1;
  }

  branch(numBranches, lengthRange, depth) {
    if (this.mainBranch) {
      this.mainBranch.branch(numBranches, lengthRange, depth);
    }
  }

  createBB() {
    this.mainBranch.createBB();
  }

  getBB() {
    return this.mainBranch.getBB();
  }

  draw() {
    this.mainBranch.draw();
  }

}

// let sketch = function(p) {
//     p.setup = function() {
//         p.createCanvas(W, H);

//         tree = new Tree(new p5.Vector(W / 2, H - 50), new p5.Vector(0, -1), ROOT_THICKNESS)
//         tree.branch(BRANCHES_PER_LEVEL, INITIAL_LENGTH_RANGE, BRANCH_DEPTH)
//         // tree.createBB();
//         // const bb = tree.getBB();
//         console.log("Tree with ", tree.totalNumBranches, " branches generated")
//   };
//   new p5(sketch, window.document.getElementById('container'));
// }
function setup() {
  const canvas = createCanvas(W, H);
  canvas.parent("container")

  tree = new Tree(new p5.Vector(W / 2, H - 100), new p5.Vector(0, -1), ROOT_THICKNESS)
  tree.branch(BRANCHES_PER_LEVEL, INITIAL_LENGTH_RANGE, BRANCH_DEPTH)
  // tree.createBB();
  // const bb = tree.getBB();
  console.log("Tree with ", tree.totalNumBranches, " branches generated")


}
function draw() {
  background(255);

  if (DEBUG_DRAWS) {
    stroke(0, 255, 0)
    const bb = tree.getBB();
    rect(...bb)
  }
  color(0)

  tree.draw()
  frameRate(FRAME_RATE);
  textSize(22);
  fill(255,255,255)
  stroke(50)
  strokeWeight(2)
  textFont('Monospace')
  paramString = `# Branches: ${tree.totalNumBranches}\nBranch Depth: ${BRANCH_DEPTH}\nBranch Split:${BRANCHES_PER_LEVEL}`
  text(paramString, 10, H-60);

  save("myPNG.png")
  save("mySVG.svg"); // give file name
//   print("saved svg");
  noLoop(); // we just want to export once
//   fill(0, 102, 153);
//   text('word', 10, 60);
//   fill(0, 102, 153, 51);
//   text('word', 10, 90);
}